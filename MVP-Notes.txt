PlanMolder – MVP Notes
======================

Laatste update: 31-12-2025

Doel van deze MVP
-----------------
- Een werkende end-to-end demo bouwen:
  - Frontend: eenvoudige Next.js interface waar een architect projectinfo kan ingeven.
  - Backend: FastAPI endpoint dat de input ontvangt en een gestructureerd antwoord terugstuurt.
- Focus ligt nu NIET op perfecte UI/UX, maar op:
  - Heldere flow.
  - Duidelijke data-structuur (zodat later een LLM kan worden aangesloten).
  - Technisch stabiele basis.

Huidige stand van zaken
-----------------------
Frontend:
- Next.js app met een formulier:
  - Velden: project_name, description, area_m2.
  - Verstuurd via fetch naar: http://127.0.0.1:8000/api/generate-answers
- Resultaatsectie toont momenteel dummy-data:
  - summary
  - advies
  - loket_choices.bouwtype
  - loket_choices.categorie
- Layout is een basic maar nette MVP:
  - Links: formulier.
  - Rechts: resultaat.
  - Nog geen definitieve branding of UX.

Backend:
- FastAPI app in Backend/main.py.
- Endpoint: POST /api/generate-answers
  - Input model: ProjectInput (project_name, description, area_m2: float).
  - Response is nu dummy / hard-coded:
    - summary: f"Samenvatting voor {project_name}"
    - advies: placeholder tekst
    - loket_choices: dummy bouwtype + categorie
- CORS is geconfigureerd voor:
  - http://localhost:3000
  - http://127.0.0.1:3000
- Backend draait lokaal op:
  - http://127.0.0.1:8000
  - Met uvicorn main:app --reload --host 127.0.0.1 --port 8000

Logic tree / logic boom – idee
------------------------------
- Doel: een "decision tree" bouwen die de architect stap voor stap helpt:
  - Op basis van input (type project, locatie, oppervlakte, functies, enz.)
  - Geeft de tool:
    - Een samenvatting.
    - Een advies (bv. vergunningsplicht, aandachtspunten).
    - Een voorstel van categorie / bouwtype voor het omgevingsloket.
- Deze boom kan later:
  - De basislogica bevatten die altijd geldt (regels, wetgeving, patronen).
  - Gecombineerd worden met een LLM:
    - LLM voor tekstuele uitleg / nuance.
    - Logic tree voor harde ja/nee-regels en categorie-keuzes.

Waarom de logic tree nog niet is uitgewerkt
-------------------------------------------
- Er moet nog duidelijker gedefinieerd worden:
  - Welke invoervelden verplicht zijn.
  - Welke variabelen het belangrijkst zijn (bijv. type: woning / handel / industrie).
  - Hoe de verschillende categorieën in het omgevingsloket precies werken.
- Daarom is er nu gekozen om eerst:
  - De end-to-end flow werkend te krijgen.
  - Een dummy-response te gebruiken met exact de velden die later door de logic tree + LLM gevuld gaan worden.

Wat later moet gebeuren (logic tree)
------------------------------------
- Input-space definiëren:
  - Welke vragen stelt de tool minimaal?
    - vb. type programma, locatie (stad / gemeente), nieuwbouw vs. verbouwing, aantal units, oppervlakte per functie, enz.
- Een eerste versie van de decision tree uitschrijven:
  - Als IF/ELSE-structuur in Python óf als JSON-config.
  - Bijvoorbeeld:
    - Als nieuwbouw woongebouw + oppervlakte > X m2 → categorie Y.
    - Als functiewijziging klein handelspand → categorie Z.
- De response van /api/generate-answers uitbreiden:
  - extra velden:
    - risks
    - required_documents
    - permit_likelihood
    - red_flags
  - Deze kunnen in eerste instantie dummy zijn, maar met de juiste keys.

Wat al mogelijk is met de huidige MVP
-------------------------------------
- Architect kan:
  - Een project ingeven (naam, beschrijving, oppervlakte).
  - Meteen een gestructureerd antwoord krijgen (dummy).
- Developer kan:
  - Frontend of backend aanpassen en direct end-to-end testen:
    - Frontend: formulier, layout, labels.
    - Backend: response-structuur, extra velden, logging.
- Het systeem is klaar om later:
  - Een echte LLM-call toe te voegen in generate-answers.
  - De logic tree stapsgewijs toe te voegen zonder de API te breken.

Checklist – korte termijn
-------------------------
[ ] Response-model uitbreiden met toekomstige velden:
    - risks, required_documents, permit_likelihood, red_flags, ...
[ ] Basic error handling op frontend:
    - Loading-state bij submit.
    - Nette foutmelding als backend niet reageert.
[ ] Een simpele logging in Backend/main.py voor ontvangen input.
[ ] Basis README toevoegen:
    - Hoe backend starten.
    - Hoe frontend starten.
    - Welke URL's gebruikt worden.

Checklist – logic tree (later)
------------------------------
[ ] Belangrijkste parameters bepalen (per type project).
[ ] Eerste draft van decision tree op papier / in tekst.
[ ] Implementatie in Python (if/else of config-gedreven).
[ ] Unit tests voor een paar voorbeeldcases.
[ ] Aansluiting met LLM-output (LLM vult teksten, logic tree bewaakt regels).






Auth / Accounts – huidige visie
-------------------------------
Doel:
- Gebruikers (architecten) kunnen inloggen of een account gebruiken zodat:
  - Hun projecten en invoer aan een user gekoppeld kunnen worden.
  - Later: meerdere architecten binnen één kantoor kunnen werken met eigen geschiedenis.
- Voor de MVP is veiligheid minder belangrijk dan:
  - Eenvoudige flow.
  - Demo-ervaring ("ik log in als architect X en zie mijn projecten").

Wat kan NU al zonder database?
------------------------------
Zonder DB zijn er twee simpele opties die vooral geschikt zijn voor demo / UX tests:

1) Dummy users in de backend (in-memory)
   - In Backend/main.py een kleine hard-coded userlijst:
     - Voorbeeld: users = [{"email": "demo@planmolder.ai", "password": "test123", "user_id": "demo-architect-1"}]
   - Endpoint /auth/login:
     - Ontvangt email + password.
     - Checkt tegen de in-memory lijst.
     - Als ok: return { "user_id": "...", "name": "..."}.
   - Nadeel:
     - Data blijft alleen in het geheugen van de server.
     - Alles is weg als de backend herstart.
   - Doel:
     - Flow kunnen tonen: "Login -> gepersonaliseerde MVP-ervaring".

2) Opslag in frontend (localStorage)
   - Frontend bewaart:
     - Ingelogde user (user_id, naam, email) in localStorage.
     - Optioneel: laatste 3 projecten (input + result) per user_id.
   - Nadeel:
     - Alleen op dat ene device / browser.
     - Niet veilig, maar prima voor een interne MVP.
   - Voordeel:
     - Geen extra backend / DB-complexiteit nu.
     - Architect kan pagina refreshen en blijft pseudo-ingelogd.

Wat NIET kan zonder database
----------------------------
- Echte, betrouwbare opslag van:
  - Alle projecten per gebruiker.
  - Historiek over meerdere sessies, devices en dagen.
- Multi-user scenario's:
  - Meerdere architecten tegelijk met hun eigen dataset.
- Rechten / rollen (bijv. admin vs. gewone user).

Hiervoor is later een echte database nodig (bijv. PostgreSQL, Supabase, Firebase, ...).

To-do voor Auth (kortetermijn, zonder DB)
-----------------------------------------
[ ] Backend: simpele, dummy login endpoint toevoegen:
    - POST /auth/login met body: { "email": "", "password": "" }
    - Hard-coded userlijst in main.py voor demo-gebruikers.
    - Response: { "user_id", "name", "email" } (geen echte tokens nodig voor MVP).
[ ] Frontend: basic login-flow bouwen:
    - Login-form met email + password.
    - Na succesvolle login:
      - user opslaan in React state + localStorage.
      - MVP-scherm (formulier + AI dummy) alleen tonen als user is ingelogd.
[ ] Optional: "Logout"-knop die localStorage + state leegt.

To-do voor Auth (later, met DB)
-------------------------------
[ ] Kiezen van auth-strategie:
    - NextAuth.js + database (PostgreSQL / Supabase)
    - Of externe auth provider (Supabase, Firebase Auth, Auth0, ...)
[ ] User-model definiëren:
    - id, email, naam, rol, kantoor, taal, timestamps.
[ ] Projects per user in DB opslaan:
    - project_id, user_id, input, AI-output, timestamps.
[ ] Frontend integreren met echte auth:
    - Sessions / cookies.
    - Beschermde routes (alleen ingelogde users zien bepaalde pagina's).

Belangrijk:
- Voor de huidige MVP is het oké om:
  - Met dummy users te werken.
  - Alleen de UX van "inloggen" te testen.
- Productie / betalende klanten:
  - Vereist een echte database + solide auth.

